= Автоматическая генерация технической документации
:lang: ru
:sectnums:
:md:

:title_img: vot_ona.png
:adoc_baza_dannyhx_png: adoc_baza_dannyhx.png
:adoc_egrul_vmeste_png: adoc_egrul_vmeste.png
:general_png: general.png

ifdef::md[]
:title_img: https://habrastorage.org/webt/dm/gt/lq/dmgtlqavf9vvl30g8hbtnyirxjo.png
:adoc_baza_dannyhx_png: https://habrastorage.org/webt/eh/ij/qk/ehijqkjfk8e64ogx3zo5aomx63u.png
:adoc_egrul_vmeste_png: https://habrastorage.org/webt/mj/h-/6_/mjh-6_n36odw71vbmj-itjbnis0.png
:general_png: https://habrastorage.org/webt/g-/mx/jd/g-mxjdbl4ya0quccx1iizd2ecai.png
endif::[]

image::{title_img}[]

Продолжая тему использования Asciidoc (и других аналогичных форматов) для организации процессов непрерывного документирования, хочу рассмотреть тему автоматический генерации технической документации.

Автоматическая генерация документации -- распространенный, но очень расплывчатый термин. Я понимаю под этим термином извлечение для представления в удобном виде информации, содержащейся в исходном коде и настройках документируемой программы (информационной системы).

== Общая схема автоматической генерации документации

Если рассматривать процесс автоматической генерации как чёрный ящик, то на входе имеем исходный код, а на выходе -- документацию или её фрагмент. Однако в реальности при автоматической генерации документации целесообразны еще два промежуточных звена.

* преобразование исходного кода в структурированный формат. Шаг обусловлен тем, что для получения документов используются шаблонизаторы. Все современные технологии, связанные с генерацией человеко-читаемых документов, пользовательских интерфейсов, программного кода, активно используют шаблонизаторы, подключаемые в виде библиотек или реализованные внутри программного кода. Вход для шаблонизатора -- структура данных, которую легко получить из файлов в форматах JSON/YAML или XML;
* преобразование структурированного формата в один из форматов документации (обычно Asciidoc, DITA, Docbook, Markdown, reStructuredText).

За исключением самых простых случаев документация готовится в различных выходных форматах (html, docx, odt, pdf и т.п.) и собирается из разных источников (в том числе не автоматически генерируемых) поэтому целесообразно использовать специальные форматы, для подготовки документации. Предположим, необходимо подготовить документацию по стандартам ЕСКД? Эта проблема, описана в https://habr.com/ru/post/558940/[предыдущей статье]. При решении проблем автоматической генерации хватает проблем и без требований ГОСТ.

Общая схема генерации документации выглядит следующим образом:

ifdef::md[]
image::{general_png}[fitrect="170x240mm", srcdpi=150, width="50%"]
endif::[]

ifndef::md[]
[plantuml,general,png,fitrect="170x240mm", srcdpi=100, width="50%"]
....
skinparam dpi 100
skinparam defaultTextAlignment center

component "Исходный код" as isx_kod
component promezhutochnyhj_format [
    Промежуточный структурированный
    формат
]
isx_kod --> promezhutochnyhj_format
component "Формат документации" as format_dokumetaczii
promezhutochnyhj_format --> format_dokumetaczii
component "Конечный формат" as konechnyj_format
format_dokumetaczii --> konechnyj_format
....
endif::[]

Рассмотрим практические приёмы, которые можно использовать при реализации ИТ-проектов. Для примеров будем использовать Asciidoc, однако приёмы применимы к любым языкам разметки текста(reStructuredText, Markdown), и текстовым маркапам для построения диаграмм (рекомендую проект https://kroki.io/[kroki], который позволяет быстро ознакомиться и внедрить наиболее популярные средства построения диаграмм).

== Преобразование исходного кода в структурированный формат

Единых подходов к превращению исходного кода в структурированный формат не существует. Рассмотрим наиболее частые варианты.

=== Информация для документации извлекается из структуры исходного кода

Как правило, используются дополнительные средства языка, обычно комментарии в специальном формате (комментарии Javadoc, ReST и т.п.) и аннотации.

Средств, обеспечивающих преобразование исходного кода в документацию, причём очень зрелых, много. Можно смело брать и использовать подходящие для конкретного проекта. Разработка собственных средств затратна. Мы пошли указанным путём только раз, разрабатывая https://github.com/CourseOrchestra/2bass[проект для миграции структуры базы данных]. Целесообразность определялась использованием средства во всех наших проектах и желанием попробовать свои силы.

Следующие подходы более гибки с точки зрения настройки автоматической генерации документации в реализуемых проектах.

=== Структурированный формат получается как один из результатов исполнения исходного кода

При данном подходе считывается и сохраняется в структурированный формат состояния объектов (например, структуры базы данных, конфигурации развернутой среды информационной системы и т.п.), создаваемых в результате работы приложения.

Отдельно отметим использование для документирвоания логов. Типовой пример -- тесты. Например, большинство инструментов для тестирования выдают результаты в формате Junit xml report. Это, позволяет сделать универсальные инструменты генерации отчётности по тестам, самый известный, наверное -- https://docs.qameta.io/allure[Allure Framework].

В https://habr.com/ru/company/alfa/blog/454720/[этой статье] показано, как используют JSON-файлы, которые генерирует при работе https://cucumber.io/[Cucumber], как документация строится на основе логов, создаваемых в результате работы тестов.

Типовой пример создания документации на основе считывания состояния объектов, создаваемых в результате работы приложения, -- документирование структуры БД. В конце раздела приведен пример, иллюстрирующий данный подход.

=== Исходный код сразу представляет собой структурированный формат

Многие языки уже реализованы в структурированном формате (например, xsd-схемы, OpenAPI, различные https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA[DSL] для описания предметной области, файлы настроек).

Иногда проводят предварительную обработку этих форматов, например, объединение спецификации в единую иерархическую структуру (так называемая операция «flatten»).

Частным (и частым) случаем является ситуация, когда настройки содержатся в базе данных.

=== Пример -- генерация документации по структуре базы данных

Пример иллюстрирует достаточно частую ситуацию, когда информация для документации хранится в таблицах СУБД.

Создаём скрипт, описывающий структуру БД. Этот скрипт не выглядит как исходник для поддержания структуры БД, однако, как это не парадоксально, таковым является, https://github.com/CourseOrchestra/2bass[подробности в документации к уже упомянутому проекту]. Это также может быть миграционный скрипт в любой системе контроля версии базы данных.

----
include::sql.sql[tag=sql_script]
----

Применим скрипт к базе данных и воспользуемся двумя инструментами СУБД (пример приведён для https://www.postgresql.org/[PostgreSQL]): динамическими представлениями для извлечения сведений о структуре и возможностью создавать JSON-файлы на основе результатов сохранения запросов.

----
include::sql.sql[tag=get_model]
----

В результате получим JSON-файл:

----
include::schema.json[]
----

В следующем разделе будет показано, как этот файл превратить в документ.

== Использование шаблонизаторов

Для превращения структурированного файла в документ используют специальный тип языков, «https://en.wikipedia.org/wiki/Template_processor[шаблонизаторы]». Шаблонизатор позволяет задать правила обхода иерархической структуры данных и правила, по которым элементы иерархии исходного документа преобразуют в выходной документ.

Формат этих правил достаточно простой, они безопасны с точки зрения исполнения, поэтому часто шаблонизаторы используются для настройки различных аспектов работы приложений непосредственно пользователями.

Самым известным языком обработки шаблонов (но далеко не самым простым) является https://ru.wikipedia.org/wiki/XSLT[XSLT]. Самым минималистичным -- https://mustache.github.io/[Mustache].

Свой язык написания шаблонов и шаблонизатор также создать довольно просто. Например, для создания системы генерации отчётов в форматах Excel и ods мы пошли https://github.com/CourseOrchestra/xylophone[этим путём].

Можно вообще обойтись без шаблонизатора, просто структурировать код определенным образом, https://martinfowler.com/bliki/MovingAwayFromXslt.html[в этой старой статье 2003 года] Мартин Фаулер признается в нелюбви к XSLT и заодно объясняет, как его заменить кодом, написанным на языке Ruby. За 18 лет оказалось, что и статические языки также можно прекрасно использовать для этих целей, и XSLT прекрасно себя чувствует, и предложенный в статье подход оказался очень хорош.

В примерах будет использоваться https://github.com/Shopify/liquid[Liquid] для работы с JSON и XSLT для работы с XML. В обоих случаях будет использоваться реализация в Ruby, потому что (1) Наиболее распространенный в настоящий момент процессор Asciidoc -- https://github.com/asciidoctor[Asciidoctor] -- написан на Ruby (2) Ruby-скрипты отлично работают в java и javascript, что часто позволяет не плодить цирк технологий.

=== Пример генерации документа из JSON-файла

Рассмотрим простой пример по генерации документа на основе полученного выше JSON-файла.

Генерация диаграммы в формате PlantUML:

----
include::pu_sql.pu.liquid[]
----

В примере шаблонизатор обходит все узлы, определяющие таблицы. Для каждой таблицы создается строка PlantUML для отрисовки классов `class [Наименование класса]`. Далее внутри каждой таблицы проверяется наличие внешних ключей и создается соединительная линия с соответствующими классами.

На выходе получаем следующий текст диаграммы:

----
include::pu_sql.pu[]
----

Аналогично сгенерируем документ в формате Asciidoc:

----
include::adoc_sql.adoc.liquid[]
----

Для объединения обоих кусков в один документ воспользуемся директивой include:

[source]
----
= Структура БД
:lang: ru
:figure-caption: Рисунок
:xrefstyle: short
:sectnums:

== Общая структура

Структура базы данных изображена на рисунке (<<struktura>>).

[[struktura]]
.Структура БД
[plantuml, struktura, png, fitrect="170x240mm", srcdpi=300, width="50%"]
....
skinparam dpi 300
left to right direction
\include::pu_sql.pu[]
....

== Описание таблиц

\include::adoc_sql.adoc[]
----

Синтаксис Asciidoc рассмотрен в статье https://habr.com/ru/post/558940/[Asciidoc для ЕСКД]. Подробнее структурирование документации в Asciidoc планирую описать в отдельной статье. Здесь лишь хотелось бы отметить, что при вставке диаграммы мы указываем параметры её отображения. В разных документах одну и ту же диаграмму мы можем отобразить по-разному (в разных цветах, с разным разрешением, в разной ориентации и т.п.).

Результаты превращаем в файл в формате Microsoft Word с помощью проекта, о котором рассказано в https://habr.com/ru/post/556624/[предыдущей] статье.

image::{adoc_baza_dannyhx_png}[width=100%, fitrect="170x240mm"]

=== Ключевые техники, используемые при генерации документации

Для рассмотрения ключевых техник приведём пример с преобразованием XML-файла.

Для примера возьмем выписку из ЕГРЮЛ от https://www.nalog.gov.ru/rn77/[Федеральной налоговой службы]. Не совсем документация, но удобно для демонстрации основных приёмов преобразования структурированных данных в документацию.

Исходные данные (схема xsd и пример сообщения) взяты на сайте СМЭВ 3 -- https://smev3.gosuslugi.ru/portal/inquirytype_one.jsp?id=41108&zone=fed. Для примера приведём небольшую часть выписки из ЕГРЮЛ:

[source,xml]
----
<ns1:СвНаимЮЛ НаимЮЛПолн="НАИМЕНОВАНИЕ 5087746429843"
    НаимЮЛСокр="СОКРАЩЕННОЕ НАИМЕНОВАНИЕ 5087746429843">
  <ns1:ГРНДата ГРН="5087746429843" ДатаЗаписи="2008-11-18"/>
</ns1:СвНаимЮЛ>
<ns1:СвАдресЮЛ>
  <ns1:АдресРФ КодРегион="77" КодАдрКладр="770000000002990" Дом="7"
      Корпус="6">
    <fnst:Регион ТипРегион="ГОРОД" НаимРегион="МОСКВА"/>
    <fnst:Улица ТипУлица="УЛИЦА" НаимУлица="ФИЛЕВСКАЯ 2-Я"/>
    <fnst:ГРНДата ГРН="5087746429843" ДатаЗаписи="2008-11-18"/>
  </ns1:АдресРФ>
</ns1:СвАдресЮЛ>
----

Как видно, названия тэгов и атрибутов вполне говорящие, но мы возьмем полные названия параметров из схемы xsd.

Преобразование выписки из ЕГРЮЛ в формат Asciidoc выглядит следующим образом:

[source,xml]
----
include::adoc_egrul.xslt[]
----

В примере шаблонизатор обходит все узлы файла с данными ЕГРЮЛ. Тэги, в которых есть атрибуты или дополнительные тэги трансформируются в заголовок с нужным уровнем иерархии. Атрибуты и текстовые тэги -- в строки таблицы. Обратите внимание, что в Asciidoc реализован очень компактный способ задания ячейки таблицы через символ `|`.

Наименования тэгов и атрибутов XML-документа обёрнуты в фигурные скобки -- специальный синтаксис для отображения значений атрибутов Asciidoc. Значения атрибутов легко извлекаем из xsd-схемы с помощью следующего преобразования:

[source,xml]
----
include::adoc_egrul_xsd.xslt[]
----

Объеденим полученные значения атрибутов Asciidoc (два файла, т.к. описание сервиса по выдаче ЕГРЮЛ состоит из двух схем xsd) и файл с содержанием выписки:

----
:sectnums:

\include::adoc_egrul_xsd.adoc[]
\include::adoc_egrul_xsd2.adoc[]

\include::adoc_egrul.adoc[]
----

На выходе Microsoft Word даёт следующую картинку:

image::{adoc_egrul_vmeste_png}[fitrect="170x240mm"]

==== Борьба с пробельными символами

Поскольку конечным форматом преобразования является текстовая разметка, вопрос пробелов крайне важен: текст, смещенный на несколько пробелов, может быть воспринят как блок с моноширинным текстом.

Пробелы могут влиять на эстетику, читаемость и обрабатываемость выходного документа. Например, после каждого абзаца в Asciidoc должно быть два переноса строки. Их может быть и три, но читается файл хуже. Во многих автоматически сгенерированных документах количество переносов строк абсолютно не предсказуемо. Особенно это неудобно при сравнении версий файла. При наличии на выходе файла в формате XML или JSON можно было бы применить утилиты, создающие красивый выходной файл. Для текстовых маркапов, насколько я знаю, таких утилит не существует.

С другой стороны, крайне важно, чтобы сам шаблон был красивым и удобным для чтения и редактирования, чтобы, как минимум, были отступы в циклах и условных операторах.

Поработав со многими шаблонизаторами, пришёл к выводу, что единственный практически универсальный вариант -- указать шаблонизатору, чтобы он вырезал все пробелы и переносы, а переносы указывать вручную в шаблоне. В приведенном примере есть опция `<strip-space elements="*"/>` и после каждой выводимой строчки помещена команда `<text>\n</text>`. Некоторые шаблонизаторы воспринимают `\n` как символ переноса. Если нет, необходимо провести пост-обработку выходного файла и самостоятельно заменять данную комбинацию на перенос строки.

В примере для Liquid применен аналогичный подход, только для наглядности символ переноса присвоен переменной `bl`.

==== Рекурсия

Рекурсия обеспечивает наглядный способ обхода узлов структурированного документа с большим количеством единообразных уровней иерархии, как в приведённой выписке из ЕГРЮЛ.

Рекурсию поддерживает большинство шаблонизаторов. Например, XSLT поддерживает рекурсию директивой `apply-templates`. В примере основной шаблон (`template`) обеспечивает обработку иерархического узла выписки из ЕГРЮЛ и далее вызывает себя для каждого узла ниже по иерархии.

==== Экранирование и другие операции со вставляемыми данными

Данные для вставки в Asciidoc файл могут вступить в конфликт с разметкой Asciidoc. Например, вы хотите взять текст из Open API спецификации и добавить символ «`;`». Однако разработчик мог при описании сам поставить тот же символ. В результате в выходной файл попадёт два символа «`;;`» и Asciidoc будет воспринимать текст как терминологический список, и хорошо ещё, если мы быстро поймём, почему на выходе текст отформатирован странно.

Чтобы этого избежать, можно оборачивать вставляемый текст собственными функциями, которые экранируют и производят требуемые преобразования значений. В примере -- это функция `iformat`. Она добавляет в начале и в конце значения символ нулевого пробела (zero space) и переводит значения типа даты в формат DD.MM.YYYY.

[source, ruby]
----
include::run_liquid.rb[tag=iformat]
----

Для полного отключения синтаксиса Asciidoc во вставляемых значениях, достаточно их просто экранировать.

== Выводы

* Технологии автоматической генерации документации отработаны и их могут быть эффективно использованы в ИТ-проектах любого уровня сложности.

* Язык разметки Asciidoc технологичен для применения в задачах автоматической генерации документации.

И анонс: следующая статья будет посвящена вопросам обеспечения качества документации в формате Asciidoc.



